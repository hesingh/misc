```c
/* Automatically generated by p4c-bm2-vpp from ../testdata/p4_16_samples/vpp_parse.p4 on Wed Sep 30 23:43:38 2020
 */
#include "tst.h"

#define CGEN_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)

void* memcpy(void* dest, const void* src, size_t num);

static void *(*ubpf_map_lookup)(const void *, const void *) = (void *)1;
static int (*ubpf_map_update)(void *, const void *, void *) = (void *)2;
static int (*ubpf_map_delete)(void *, const void *) = (void *)3;
static int (*ubpf_map_add)(void *, const void *) = (void *)4;
static uint64_t (*ubpf_time_get_ns)() = (void *)5;
static uint32_t (*ubpf_hash)(const void *, uint64_t) = (void *)6;
static void (*ubpf_printf)(const char *fmt, ...) = (void *)7;
static void *(*ubpf_packet_data)(const void *) = (void *)9;
static void *(*ubpf_adjust_head)(const void *, uint64_t) = (void *)8;
static uint32_t (*ubpf_truncate_packet)(const void *, uint64_t) = (void *)11;


#define write_partial(a, w, s, v) do { *((uint8_t*)a) = ((*((uint8_t*)a)) & ~(CGEN_MASK(uint8_t, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(uint8_t*)((base) + (offset)) = (v); } while (0)

static uint32_t
bpf_htonl(uint32_t val) {
    return htonl(val);
}
static uint16_t
bpf_htons(uint16_t val) {
    return htons(val);
}
static uint64_t
bpf_htonll(uint64_t val) {
    return htonll(val);
}

uint64_t entry(void *ctx, struct metadata_t *meta){
    struct headers_t hdr = {
        .bridged_md = {
            .cgen_valid = 0
        },
        .ethernet = {
            .cgen_valid = 0
        },
        .mpls = {{
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        } },
        .lic = {
            .cgen_valid = 0
        },
        .ipv4 = {
            .cgen_valid = 0
        },
        .ipv6 = {
            .cgen_valid = 0
        },
        .udp = {
            .cgen_valid = 0
        },
        .tcp = {
            .cgen_valid = 0
        },
        .sctp = {
            .cgen_valid = 0
        },
        .gtpu_hdr = {
            .cgen_valid = 0
        },
        .gtpu_opts = {{
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        }, {
            .cgen_valid = 0
        } },
        .gtpu_opt = {
            .cgen_valid = 0
        },
        .inner_ethernet = {
            .cgen_valid = 0
        },
        .inner_ipv4 = {
            .cgen_valid = 0
        },
        .inner_ipv6 = {
            .cgen_valid = 0
        },
        .inner_udp = {
            .cgen_valid = 0
        },
        .inner_tcp = {
            .cgen_valid = 0
        },
        .inner_sctp = {
            .cgen_valid = 0
        },
    };
    unsigned cgen_packetOffsetInBits = 0;
    unsigned cgen_packetOffsetInBits_save = 0;
    meta = NULL;
    uint8_t pass = 1;
    uint32_t cgen_zero = 0;
    unsigned char cgen_byte;
    int packetTruncatedSize = -1;

    void *pkt = ?? // TODO VPP
    uint32_t pkt_len = // TODO VPP
    
    goto start;
    start: {

        meta->egress_port = 1;	/* extract(hdr.ethernet)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 112)) {
            goto reject;
        }
        
        hdr.ethernet.dstAddr = (uint64_t)((load_dword(pkt, BYTES(cgen_packetOffsetInBits)) >> 16) & CGEN_MASK(uint64_t, 48));
        cgen_packetOffsetInBits += 48;

        hdr.ethernet.srcAddr = (uint64_t)((load_dword(pkt, BYTES(cgen_packetOffsetInBits)) >> 16) & CGEN_MASK(uint64_t, 48));
        cgen_packetOffsetInBits += 48;

        hdr.ethernet.etherType = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.ethernet.cgen_valid = 1;

        switch (hdr.ethernet.etherType) {
            case 0x800: goto parse_ipv4;
            case 0x86dd: goto parse_ipv6;
            default: goto accept;
        }
    }
    parse_ipv4: {
	/* extract(hdr.ipv4)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 160)) {
            goto reject;
        }
        
        hdr.ipv4.version = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits)) >> 4) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.ipv4.ihl = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.ipv4.diffServ = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.ipv4.totalLen = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.ipv4.identification = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.ipv4.flags = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits)) >> 5) & CGEN_MASK(uint8_t, 3));
        cgen_packetOffsetInBits += 3;

        hdr.ipv4.fragOffset = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))) & CGEN_MASK(uint16_t, 13));
        cgen_packetOffsetInBits += 13;

        hdr.ipv4.ttl = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.ipv4.protocol = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.ipv4.hdrChecksum = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.ipv4.srcAddr = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.ipv4.dstAddr = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.ipv4.cgen_valid = 1;

        switch (hdr.ipv4.protocol) {
            case 6: goto parse_tcp;
            case 17: goto parse_udp;
            case 132: goto parse_sctp;
            default: goto accept;
        }
    }
    parse_ipv6: {
	/* extract(hdr.ipv6)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 320)) {
            goto reject;
        }
        
        hdr.ipv6.version = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits)) >> 4) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.ipv6.trafficClass = (uint8_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits)) >> 4) & CGEN_MASK(uint8_t, 8));
        cgen_packetOffsetInBits += 8;

        hdr.ipv6.flowLabel = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits)) >> 8) & CGEN_MASK(uint32_t, 20));
        cgen_packetOffsetInBits += 20;

        hdr.ipv6.payloadLen = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.ipv6.nextHdr = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.ipv6.hopLimit = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.ipv6.srcAddr[0] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 0) >> 0));
        hdr.ipv6.srcAddr[1] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 1) >> 0));
        hdr.ipv6.srcAddr[2] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 2) >> 0));
        hdr.ipv6.srcAddr[3] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 3) >> 0));
        hdr.ipv6.srcAddr[4] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 4) >> 0));
        hdr.ipv6.srcAddr[5] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 5) >> 0));
        hdr.ipv6.srcAddr[6] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 6) >> 0));
        hdr.ipv6.srcAddr[7] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 7) >> 0));
        hdr.ipv6.srcAddr[8] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 8) >> 0));
        hdr.ipv6.srcAddr[9] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 9) >> 0));
        hdr.ipv6.srcAddr[10] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 10) >> 0));
        hdr.ipv6.srcAddr[11] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 11) >> 0));
        hdr.ipv6.srcAddr[12] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 12) >> 0));
        hdr.ipv6.srcAddr[13] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 13) >> 0));
        hdr.ipv6.srcAddr[14] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 14) >> 0));
        hdr.ipv6.srcAddr[15] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 15) >> 0));
        cgen_packetOffsetInBits += 128;

        hdr.ipv6.dstAddr[0] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 0) >> 0));
        hdr.ipv6.dstAddr[1] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 1) >> 0));
        hdr.ipv6.dstAddr[2] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 2) >> 0));
        hdr.ipv6.dstAddr[3] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 3) >> 0));
        hdr.ipv6.dstAddr[4] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 4) >> 0));
        hdr.ipv6.dstAddr[5] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 5) >> 0));
        hdr.ipv6.dstAddr[6] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 6) >> 0));
        hdr.ipv6.dstAddr[7] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 7) >> 0));
        hdr.ipv6.dstAddr[8] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 8) >> 0));
        hdr.ipv6.dstAddr[9] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 9) >> 0));
        hdr.ipv6.dstAddr[10] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 10) >> 0));
        hdr.ipv6.dstAddr[11] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 11) >> 0));
        hdr.ipv6.dstAddr[12] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 12) >> 0));
        hdr.ipv6.dstAddr[13] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 13) >> 0));
        hdr.ipv6.dstAddr[14] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 14) >> 0));
        hdr.ipv6.dstAddr[15] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 15) >> 0));
        cgen_packetOffsetInBits += 128;

        hdr.ipv6.cgen_valid = 1;

        switch (hdr.ipv6.nextHdr) {
            case 17: goto parse_udp;
            case 6: goto parse_tcp;
            case 132: goto parse_sctp;
            case 4: goto parse_ipv4_in_ip;
            case 41: goto parse_ipv6_in_ip;
            default: goto accept;
        }
    }
    parse_tcp: {
	/* extract(hdr.tcp)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 160)) {
            goto reject;
        }
        
        hdr.tcp.srcPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.tcp.dstPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.tcp.seqNo = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.tcp.ackNo = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.tcp.dataOffset = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits)) >> 4) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.tcp.res = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.tcp.flags = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.tcp.window = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.tcp.checksum = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.tcp.urgentPtr = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.tcp.cgen_valid = 1;

        meta->_acl_l4dstPort4 = hdr.tcp.dstPort;
        meta->_acl_l4srcPort3 = hdr.tcp.srcPort;
        goto accept;
    }
    parse_udp: {
	/* extract(hdr.udp)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 64)) {
            goto reject;
        }
        
        hdr.udp.srcPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.udp.dstPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.udp.length_ = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.udp.checksum = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.udp.cgen_valid = 1;

        meta->_acl_l4dstPort4 = hdr.udp.dstPort;
        meta->_acl_l4srcPort3 = hdr.udp.srcPort;
        goto accept;
    }
    parse_sctp: {
	/* extract(hdr.sctp)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 96)) {
            goto reject;
        }
        
        hdr.sctp.srcPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.sctp.dstPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.sctp.verifTag = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.sctp.checksum = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.sctp.cgen_valid = 1;

        meta->_acl_l4dstPort4 = hdr.sctp.dstPort;
        meta->_acl_l4srcPort3 = hdr.sctp.srcPort;
        goto accept;
    }
    parse_ipv4_in_ip: {
	/* extract(hdr.inner_ipv4)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 160)) {
            goto reject;
        }
        
        hdr.inner_ipv4.version = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits)) >> 4) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.inner_ipv4.ihl = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.inner_ipv4.diffServ = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.inner_ipv4.totalLen = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_ipv4.identification = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_ipv4.flags = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits)) >> 5) & CGEN_MASK(uint8_t, 3));
        cgen_packetOffsetInBits += 3;

        hdr.inner_ipv4.fragOffset = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))) & CGEN_MASK(uint16_t, 13));
        cgen_packetOffsetInBits += 13;

        hdr.inner_ipv4.ttl = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.inner_ipv4.protocol = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.inner_ipv4.hdrChecksum = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_ipv4.srcAddr = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.inner_ipv4.dstAddr = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.inner_ipv4.cgen_valid = 1;

        switch (hdr.inner_ipv4.protocol) {
            case 6: goto parse_inner_tcp;
            case 17: goto parse_inner_udp;
            case 132: goto parse_inner_sctp;
            default: goto accept;
        }
    }
    parse_ipv6_in_ip: {
	/* extract(hdr.inner_ipv6)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 320)) {
            goto reject;
        }
        
        hdr.inner_ipv6.version = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits)) >> 4) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.inner_ipv6.trafficClass = (uint8_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits)) >> 4) & CGEN_MASK(uint8_t, 8));
        cgen_packetOffsetInBits += 8;

        hdr.inner_ipv6.flowLabel = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits)) >> 8) & CGEN_MASK(uint32_t, 20));
        cgen_packetOffsetInBits += 20;

        hdr.inner_ipv6.payloadLen = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_ipv6.nextHdr = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.inner_ipv6.hopLimit = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.inner_ipv6.srcAddr[0] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 0) >> 0));
        hdr.inner_ipv6.srcAddr[1] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 1) >> 0));
        hdr.inner_ipv6.srcAddr[2] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 2) >> 0));
        hdr.inner_ipv6.srcAddr[3] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 3) >> 0));
        hdr.inner_ipv6.srcAddr[4] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 4) >> 0));
        hdr.inner_ipv6.srcAddr[5] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 5) >> 0));
        hdr.inner_ipv6.srcAddr[6] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 6) >> 0));
        hdr.inner_ipv6.srcAddr[7] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 7) >> 0));
        hdr.inner_ipv6.srcAddr[8] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 8) >> 0));
        hdr.inner_ipv6.srcAddr[9] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 9) >> 0));
        hdr.inner_ipv6.srcAddr[10] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 10) >> 0));
        hdr.inner_ipv6.srcAddr[11] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 11) >> 0));
        hdr.inner_ipv6.srcAddr[12] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 12) >> 0));
        hdr.inner_ipv6.srcAddr[13] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 13) >> 0));
        hdr.inner_ipv6.srcAddr[14] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 14) >> 0));
        hdr.inner_ipv6.srcAddr[15] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 15) >> 0));
        cgen_packetOffsetInBits += 128;

        hdr.inner_ipv6.dstAddr[0] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 0) >> 0));
        hdr.inner_ipv6.dstAddr[1] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 1) >> 0));
        hdr.inner_ipv6.dstAddr[2] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 2) >> 0));
        hdr.inner_ipv6.dstAddr[3] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 3) >> 0));
        hdr.inner_ipv6.dstAddr[4] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 4) >> 0));
        hdr.inner_ipv6.dstAddr[5] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 5) >> 0));
        hdr.inner_ipv6.dstAddr[6] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 6) >> 0));
        hdr.inner_ipv6.dstAddr[7] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 7) >> 0));
        hdr.inner_ipv6.dstAddr[8] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 8) >> 0));
        hdr.inner_ipv6.dstAddr[9] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 9) >> 0));
        hdr.inner_ipv6.dstAddr[10] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 10) >> 0));
        hdr.inner_ipv6.dstAddr[11] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 11) >> 0));
        hdr.inner_ipv6.dstAddr[12] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 12) >> 0));
        hdr.inner_ipv6.dstAddr[13] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 13) >> 0));
        hdr.inner_ipv6.dstAddr[14] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 14) >> 0));
        hdr.inner_ipv6.dstAddr[15] = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits) + 15) >> 0));
        cgen_packetOffsetInBits += 128;

        hdr.inner_ipv6.cgen_valid = 1;

        switch (hdr.inner_ipv6.nextHdr) {
            case 17: goto parse_inner_udp;
            case 6: goto parse_inner_tcp;
            case 132: goto parse_inner_sctp;
            default: goto accept;
        }
    }
    parse_inner_sctp: {
	/* extract(hdr.inner_sctp)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 96)) {
            goto reject;
        }
        
        hdr.inner_sctp.srcPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_sctp.dstPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_sctp.verifTag = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.inner_sctp.checksum = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.inner_sctp.cgen_valid = 1;

        goto accept;
    }
    parse_inner_tcp: {
	/* extract(hdr.inner_tcp)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 160)) {
            goto reject;
        }
        
        hdr.inner_tcp.srcPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_tcp.dstPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_tcp.seqNo = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.inner_tcp.ackNo = (uint32_t)((load_word(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 32;

        hdr.inner_tcp.dataOffset = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits)) >> 4) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.inner_tcp.res = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))) & CGEN_MASK(uint8_t, 4));
        cgen_packetOffsetInBits += 4;

        hdr.inner_tcp.flags = (uint8_t)((load_byte(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 8;

        hdr.inner_tcp.window = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_tcp.checksum = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_tcp.urgentPtr = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_tcp.cgen_valid = 1;

        goto accept;
    }
    parse_inner_udp: {
	/* extract(hdr.inner_udp)*/
        if (pkt_len < BYTES(cgen_packetOffsetInBits + 64)) {
            goto reject;
        }
        
        hdr.inner_udp.srcPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_udp.dstPort = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_udp.length_ = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_udp.checksum = (uint16_t)((load_half(pkt, BYTES(cgen_packetOffsetInBits))));
        cgen_packetOffsetInBits += 16;

        hdr.inner_udp.cgen_valid = 1;

        goto accept;
    }

    reject: { return 1; }

    accept:
    {
    }
 }
```
